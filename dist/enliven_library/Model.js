// Generated by CoffeeScript 1.6.2
(function() {
  var Model, ModelGroup, ModelObject,
    __operators = Object.prototype.operators = function(operator, object) { switch (operator) {case '+': return this + object;case '-': return this - object;case '/':return this / object;case '*':return this * object;case '%':return this % object;case '^':return this ^ object;default:throw SyntaxError('Object does not support "' + operator + '" operator');}},
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Model = Model = (function() {
    var LOCAL_RIGHT, LOCAL_UP, LOCAL_VIEW, _dirQuat, _dirRightVec, _dirUpVec, _dirVec;

    Model._idCounter = 0;

    LOCAL_VIEW = new Vec3([0, 0, -1]);

    LOCAL_RIGHT = new Vec3([1, 0, 0]);

    LOCAL_UP = new Vec3([0, 1, 0]);

    function Model(options) {
      this.id = Model._idCounter++;
      this.rotation = new Quat([]).setIdentity();
      this._position = new Vec3([]);
      this.matrices = {
        mv: new Mat4([]).setIdentity(),
        imv: new Mat4([]).setIdentity(),
        n: new Mat3([]).setIdentity()
      };
      this.reset();
      this._isValid = false;
      this._viewVector = new Vec3([]);
      this._upVector = new Vec3([]);
      this._rightVector = new Vec3([]);
      if (options) {
        if (options.position) {
          this._position = options.position;
        }
        if (options.direction) {
          this.direction = options.direction;
        }
      }
      this.init();
    }

    Model.prototype.init = function() {};

    Model.prototype.reset = function() {
      this._position = new Vec3([0, 0, 0]);
      return this.rotation = new Quat([0, 0, 0, 1]);
    };

    _dirVec = new Vec3([]);

    _dirRightVec = new Vec3([]);

    _dirUpVec = new Vec3([]);

    _dirQuat = new Quat([]);

    Model.prototype.getDirection = function() {
      if (!this.isValid()) {
        this.validate();
      }
      return this._viewVector;
    };

    Model.prototype.setDirection = function(dir) {
      var rotquat, vec;
      dir.copyTo(_dirVec);
      vec = _dirVec;
      vec.normalize();
      /*
      if @_fixedYaw
        # negating so that right, up, vec is right-handed
        vec3.negate()
        right = vec3.normalize _dirRightVec, vec3[].cross _dirRightVec, @_fixedYawAxis, vec
        up    = vec3.normalize _dirUpVec,    vec3[].cross _dirUpVec,    vec, right
        quat.setAxes @rotation, vec, right, up
      else
      */

      rotquat = _dirQuat.rotationTo(this.getDirection(), vec);
      this.rotation = (rotquat).operators("*",this.rotation);
      this.rotation.normalize();
      return this.invalidate();
    };

    Model.prototype.getRight = function() {
      if (!this.isValid()) {
        this.validate();
      }
      return this._rightVector;
    };

    Model.prototype.getUp = function() {
      if (!this.isValid()) {
        this.validate();
      }
      return this._upVector;
    };

    Model.prototype.getPosition = function() {
      return this._position.clone();
    };

    Model.prototype.getHorizontalPlane = function() {
      var position;
      position = this.getPosition();
      return [position, (position).operators("+",this.getRight()), (position).operators("+",this.getDirection())];
    };

    Model.prototype.getWorldXYPlane = function() {
      var position;
      position = this.getPosition();
      return new Geometry.Plane(position, LOCAL_VIEW);
    };

    Model.prototype.getWorldXZPlane = function() {
      var position;
      position = this.getPosition();
      return new Geometry.Plane(position, LOCAL_UP);
    };

    Model.prototype.getWorldYZPlane = function() {
      var position;
      position = this.getPosition();
      return new Geometry.Plane(position, LOCAL_RIGHT);
    };

    Model.prototype.setPosition = function(x) {
      x.copyTo(this._position);
      return this._stale = true;
    };

    Model.prototype.invalidate = function() {
      this._isValid = false;
      return this._stale = true;
    };

    Model.prototype.isValid = function() {
      return this._isValid;
    };

    Model.prototype.recalculateMatrices = function() {
      if (!this.isValid()) {
        this.validate();
      }
      this._stale = false;
      this.matrices.mv.fromRotationTranslation(this.rotation, this.getPosition());
      this.matrices.imv = this.matrices.mv.getInverted();
      this.matrices.n = new Mat3([]).fromMat4(this.matrices.imv);
      return this.matrices.n = this.matrices.n.transpose();
    };

    Model.prototype.validate = function() {
      this._isValid = true;
      this._viewVector.transformQuat(LOCAL_VIEW, this.rotation);
      this._rightVector.transformQuat(LOCAL_RIGHT, this.rotation);
      return this._upVector.transformQuat(LOCAL_UP, this.rotation);
    };

    Model.prototype.rotate = function(amount, vec) {
      vec = vec.transformQuat(vec, this.rotation);
      return this.rotateWorld(amount, vec);
    };

    Model.prototype.rotateWorld = function(amount, vec) {
      var rotquat;
      rotquat = new Quat([]).setAxisAngle(vec, amount);
      rotquat.normalize();
      this.rotation = (rotquat).operators("*",this.rotation);
      this.invalidate();
      return this;
    };

    Model.prototype.pitch = function(amount) {
      var axis;
      axis = this.getRight();
      return this.rotateWorld(amount, axis);
    };

    Model.prototype.yaw = function(amount) {
      var axis;
      axis = this.getUp();
      return this.rotateWorld(amount, axis);
    };

    Model.prototype.roll = function(amount) {
      var axis;
      axis = this.getDirection();
      return this.rotateWorld(amount, axis);
    };

    Model.prototype.reorient = function(view, pos) {
      if (pos) {
        this.setPosition(pos);
      }
      this.setDirection(view);
      return this;
    };

    Model.prototype.lookAt = function(point, pos) {
      var view;
      if (pos) {
        this.setPosition(pos);
      } else {
        pos = this.getPosition();
      }
      view = this.getDirection();
      return this.setDirection((point).operators("-",pos));
    };

    Model.prototype.move = function(distance, direction) {
      var _moveVec;
      if (direction == null) {
        direction = this.getDirection();
      }
      _moveVec = direction.clone();
      this.setPosition((_moveVec.scale(distance)).operators("+",this.getPosition()));
      this.invalidate();
      return this;
    };

    Model.prototype.getTransformationMatrix = function() {
      if (this._stale) {
        this.recalculateMatrices();
      }
      return this.matrices.mv;
    };

    Model.prototype.getInverseTransformationMatrix = function() {
      if (this._stale) {
        this.recalculateMatrices();
      }
      return this.matrices.imv;
    };

    Model.prototype.getNormalMatrix = function() {
      if (this._stale) {
        this.recalculateMatrices();
      }
      return this.matrices.n;
    };

    Model.prototype.pushMatrices = function(gl) {
      gl.matrixStack.push();
      return gl.matrixStack.multModelMatrix(this.getTransformationMatrix());
    };

    Model.prototype.popMatrices = function(gl) {
      return gl.matrixStack.pop();
    };

    Model.prototype.render = function(gl, options, sceneObj) {};

    Model.prototype.update = function(gl, options, sceneObj) {};

    return Model;

  })();

  window.ModelGroup = ModelGroup = (function(_super) {
    __extends(ModelGroup, _super);

    function ModelGroup(models, options) {
      this.models = models;
      this.options = options;
      ModelGroup.__super__.constructor.call(this, this.options);
    }

    ModelGroup.prototype.render = function(gl, options, sceneObj) {
      var modelObj, _i, _len, _ref;
      this.pushMatrices(gl);
      _ref = this.models;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        modelObj = _ref[_i];
        modelObj.render(gl, options, sceneObj);
      }
      return this.popMatrices(gl);
    };

    ModelGroup.prototype.update = function(gl, options, sceneObj) {
      var modelObj, _i, _len, _ref, _results;
      _ref = this.models;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        modelObj = _ref[_i];
        _results.push(modelObj.update(gl, options, sceneObj));
      }
      return _results;
    };

    return ModelGroup;

  })(Model);

  window.ModelObject = ModelObject = (function(_super) {
    __extends(ModelObject, _super);

    function ModelObject(mesh, material, options) {
      this.mesh = mesh;
      this.material = material;
      this.options = options != null ? options : {};
      ModelObject.__super__.constructor.call(this, this.options);
    }

    ModelObject.prototype.beforeRender = function(gl, options, sceneObject) {
      return this.pushMatrices(gl);
    };

    ModelObject.prototype.afterRender = function(gl, options, sceneObject) {
      return this.popMatrices(gl);
    };

    ModelObject.prototype.render = function(gl, options, sceneObject) {
      var material;
      this.beforeRender(gl, options, sceneObject);
      if ((options.picking != null) && options.picking) {
        material = PickingMaterial.get();
      } else {
        material = this.material;
      }
      this.mesh.render(gl, this, material);
      return this.afterRender(gl, options, sceneObject);
    };

    ModelObject.prototype.update = function(gl, options, sceneObject) {};

    ModelObject.prototype.collide = function(other) {
      var b0, b1, distance, transform;
      transform = (this.getInverseTransformationMatrix()).operators("*",other.getTransformationMatrix());
      b0 = this.getBounds();
      b1 = other.getBounds(transform);
      distance = ((b0.center).operators("-",b1.center)).length();
      if (distance < (b0.radius).operators("+",b1.radius)) {
        return true;
      }
      return false;
    };

    ModelObject.prototype.getBounds = function(transform) {
      var bounds;
      if (transform == null) {
        transform = null;
      }
      bounds = this.mesh.getBounds();
      if (transform === null) {
        return bounds;
      }
      bounds.center = (transform).operators("*",bounds.center);
      return bounds;
    };

    /*
    rotate: (rad, vec) ->
      @rotation = @rotation @> [rad, vec]
      
    translate: (vec) ->
      @position = @position |> vec
      
    scale: (vec) ->
      @calibration = @calibration ^> vec
    */


    return ModelObject;

  })(Model);

}).call(this);
