// Generated by CoffeeScript 1.6.2
(function() {
  var Shader, ShaderVariable,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __operators = Object.prototype.operators = function(operator, object) { switch (operator) {case '+': return this + object;case '-': return this - object;case '/':return this / object;case '*':return this * object;case '%':return this % object;case '^':return this ^ object;default:throw SyntaxError('Object does not support "' + operator + '" operator');}},
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ShaderVariable = (function() {
    function ShaderVariable() {
      this.names = [];
      this.displayNames = [];
      this.type = null;
      this.typePublic = false;
      this.typeGlobal = false;
      this.typeQualifier = null;
      this.match = {
        0: '',
        offset: 0
      };
    }

    return ShaderVariable;

  })();

  window.Shader = Shader = (function(_super) {
    __extends(Shader, _super);

    function Shader(name, guid) {
      this.name = name;
      this.guid = guid;
      this.ready = false;
      this.importing = 0;
      if (this.guid === void 0) {
        this.guid = this.generateGuid();
      }
      this.imports = [this.name];
      this.variables = null;
      this.globals = [];
    }

    Shader.prototype.generateGuid = function() {
      var c, hash, i, name, _i, _ref;
      name = this.getPublicMangler();
      hash = 0;
      for (i = _i = 0, _ref = (name.length).operators("-",1); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        c = name.charCodeAt(i);
        hash = ((((hash << 5)).operators("-",hash))).operators("+",c);
        hash = hash & hash;
      }
      return ('e').operators("+",Math.abs(hash));
    };

    Shader.prototype.getSource = function() {
      if (!this.ready) {
        this.load();
        this.compile();
      }
      return this.src;
    };

    Shader.prototype.load = function() {
      var element, k, source;
      if (Enliven.ShaderSources[this.name] !== void 0) {
        this.src = Enliven.ShaderSources[this.name];
        this.ready = true;
        return true;
      }
      element = document.getElementById(this.name);
      if (element === !null) {
        source = "";
        k = element.firstChild;
        while (k) {
          if (k.nodeType === 3) {
            source += k.textContent;
          }
          k = k.nextSibling;
        }
        this.src = Enliven.ShaderSources[this.name] = source;
        this.ready = true;
        return true;
      }
      return false;
      /*
      url = "shaders/#{@name}.glsl"
      xhr = if window.ActiveXObject
              new window.ActiveXObject('Microsoft.XMLHTTP')
            else
              new window.XMLHttpRequest()
      xhr.open 'GET', url, true
      xhr.overrideMimeType 'text/plain' if 'overrideMimeType' of xhr
      xhr.onreadystatechange = =>
        if xhr.readyState is 4
          if xhr.status in [0, 200]
            ShaderSources[@name] = xhr.responseText
            @loaded()
          else
            throw new Error "Could not load #{url}"
      xhr.send null
      */

    };

    /*
    loaded: ->
      @ready = true
      return @compile()
    
    
    imported: (name) ->
      if name isnt undefined
        @importing--;
        console.log name
    */


    Shader.prototype.compile = function(main, srcBefore, srcAfter) {
      var importInfo, imports, _i, _len;
      if (main == null) {
        main = true;
      }
      if (srcBefore == null) {
        srcBefore = "";
      }
      if (srcAfter == null) {
        srcAfter = "";
      }
      if (!this.ready) {
        this.load();
      }
      this.main = null;
      this.src = this.mangle();
      this.src = ((srcBefore).operators("+",this.src)).operators("+",srcAfter);
      imports = this.findImports();
      for (_i = 0, _len = imports.length; _i < _len; _i++) {
        importInfo = imports[_i];
        this.importShader(importInfo);
      }
      if (main) {
        this.activateMain();
      }
      if (main) {
        this.resolveNames();
      }
      this.src = this.src.replace(/(\n){2,}/g, "\n");
      this.fireEvent('ready', {});
      return this.fireEvent('changed', {});
    };

    Shader.prototype.resolveNames = function() {
      var name, regexp, _i, _len, _ref, _results;
      _ref = this.imports;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        regexp = new RegExp((("(\W)?(").operators("+",(this.getName(name)))).operators("+",")\\."), "gm");
        _results.push(this.src = this.src.replace(regexp, ("$1").operators("+",(this.getPublicMangler(name)))));
      }
      return _results;
    };

    Shader.prototype.findImports = function() {
      var importName, imports, match, offsetEnd, offsetStart, rx, src;
      imports = [];
      rx = /import[\s\t\n]*(.+?);/;
      src = this.src;
      while (match = rx.exec(src)) {
        offsetStart = match.index;
        offsetEnd = (match.index).operators("+",match[0].length);
        importName = match[1];
        src = (src.slice(0, offsetStart)).operators("+",src.slice(offsetEnd));
        imports.push({
          name: importName,
          offset: [offsetStart, offsetEnd],
          match: match[0]
        });
      }
      return imports;
    };

    Shader.prototype.findVariables = function() {
      var STATE_COMMENT_MULTI, STATE_COMMENT_SINGLE, STATE_GLOBAL, STATE_NONE, STATE_PUBLIC, STATE_QUALIFIED, STATE_TYPED, ch, match, matching, offset, processToken, removeGlobals, src, state, token, variable, variables, _i, _len, _this;
      variables = [];
      src = this.src;
      STATE_NONE = 0;
      STATE_PUBLIC = 1;
      STATE_GLOBAL = 2;
      STATE_QUALIFIED = 4;
      STATE_TYPED = 8;
      STATE_COMMENT_SINGLE = 16;
      STATE_COMMENT_MULTI = 32;
      state = STATE_NONE;
      processToken = function(token) {
        if (token === '') {
          return;
        }
        if (state === STATE_NONE) {
          switch (token) {
            case 'public':
              state |= STATE_PUBLIC;
              return variable.typePublic = true;
            case 'global':
              state |= STATE_GLOBAL;
              return variable.typeGlobal = true;
            case 'varying':
            case 'uniform':
            case 'attribute':
              state |= STATE_QUALIFIED;
              return variable.typeQualifier = token;
          }
        } else if (state & STATE_TYPED) {
          variable.names || (variable.names = []);
          return variable.names.push(token.replace(/,/, ''));
        } else if (state & STATE_QUALIFIED) {
          state |= STATE_TYPED;
          return variable.type = token;
        } else if (state & STATE_PUBLIC || state & STATE_GLOBAL) {
          switch (token) {
            case 'varying':
            case 'uniform':
            case 'attribute':
              state |= STATE_QUALIFIED;
              return variable.typeQualifier = token;
            default:
              return state = STATE_NONE;
          }
        } else {
          throw new Error(("Unexpected state: ").operators("+",state));
        }
      };
      _this = this;
      removeGlobals = function(names) {
        var defined, global, name, verifiedNames, _i, _j, _len, _len1, _ref;
        verifiedNames = [];
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          defined = false;
          _ref = _this.globals;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            global = _ref[_j];
            if (__indexOf.call(global.names, name) >= 0) {
              defined = true;
              break;
            }
          }
          if (!defined) {
            verifiedNames.push(name);
          }
        }
        return verifiedNames;
      };
      token = '';
      variable = new ShaderVariable();
      matching = [];
      match = {
        0: '',
        offset: 0
      };
      for (offset = _i = 0, _len = src.length; _i < _len; offset = ++_i) {
        ch = src[offset];
        match[0] += ch;
        if (ch === '\n' && state & STATE_COMMENT_SINGLE) {
          state ^= STATE_COMMENT_SINGLE;
          continue;
        }
        if (match[0].length >= 2 && match[0].indexOf('*/') === (match[0].length).operators("-",2) && state & STATE_COMMENT_MULTI) {
          state ^= STATE_COMMENT_MULTI;
          continue;
        }
        if (state & STATE_COMMENT_SINGLE || state & STATE_COMMENT_MULTI) {
          continue;
        }
        if (match[0].length >= 2 && match[0].indexOf('//') === (match[0].length).operators("-",2)) {
          token = token.replace(/\/$/, '');
          state |= STATE_COMMENT_SINGLE;
          continue;
        }
        if (match[0].length >= 2 && match[0].indexOf('/*') === (match[0].length).operators("-",2)) {
          token = token.replace(/\/$/, '');
          state |= STATE_COMMENT_MULTI;
          continue;
        }
        if (ch === ';') {
          processToken(token);
          if (state & STATE_TYPED) {
            variable.match = match;
            if (variable.typeGlobal) {
              variable.displayNames = removeGlobals(variable.names);
            } else {
              variable.displayNames = variable.names;
            }
            if (variable.names.length > 0) {
              variables.push(variable);
              if (variable.typeGlobal) {
                this.globals.push(variable);
              }
              variable = new ShaderVariable();
            }
          }
          state = STATE_NONE;
          match = {
            0: '',
            offset: offset
          };
          token = '';
        } else if (ch === '\n' || ch === ' ' || ch === '\t') {
          processToken(token);
          if (state === STATE_NONE) {
            match = {
              0: '',
              offset: offset
            };
          }
          token = '';
        } else {
          token += ch;
        }
      }
      return variables;
    };

    Shader.prototype.findFunctions = function() {
      var func, functions, match, offsetEnd, offsetStart, rx, signature, src;
      functions = [];
      rx = /(public[\s\t\n]+|)(\w+)[\s\t\n]+(\w+)[\s\t\n]*\([\s\t\n]*[\s\t\n]*(.*?)[\s\t\n]*\)[\s\t\n]*{/;
      src = this.src;
      while (match = rx.exec(src)) {
        offsetStart = match.index;
        offsetEnd = (match.index).operators("+",match[0].length);
        signature = match[4];
        offsetEnd += (this.scan(src.slice(offsetEnd), '}', '{').length).operators("+",1);
        func = src.slice(offsetStart, offsetEnd);
        src = (src.slice(0, offsetStart)).operators("+",src.slice(offsetEnd));
        functions.push({
          typePublic: !!match[1],
          signature: signature,
          full: func,
          type: match[2],
          name: match[3]
        });
      }
      return this.functions = functions;
    };

    Shader.prototype.scan = function(str, end, incr, decr, startIndex, singleLineComment, multiLineCommentStart, multiLineCommentEnd) {
      var ch, depth, i, inComment, result, _i, _ref;
      end = end || ')';
      incr = incr || '(';
      decr = decr || end;
      singleLineComment = singleLineComment || "//";
      multiLineCommentStart = multiLineCommentStart || "/*";
      multiLineCommentEnd = multiLineCommentEnd || "*/";
      startIndex = startIndex || 0;
      depth = 0;
      result = "";
      inComment = 0;
      for (i = _i = startIndex, _ref = (str.length).operators("-",1); startIndex <= _ref ? _i <= _ref : _i >= _ref; i = startIndex <= _ref ? ++_i : --_i) {
        ch = str[i];
        switch (ch) {
          case incr:
            if (!inComment) {
              depth++;
            }
            break;
          case decr:
            if (!inComment) {
              depth--;
            }
        }
        if (depth < 0) {
          break;
        }
        result += ch;
        if (result.length >= singleLineComment.length && result.substring((result.length).operators("-",singleLineComment.length), result.length) === singleLineComment) {
          inComment = 1;
        }
        if (inComment === 1 && ch === "\n") {
          inComment = 0;
        }
        if (!inComment && result.length >= multiLineCommentStart.length && result.substring((result.length).operators("-",multiLineCommentStart.length), result.length) === multiLineCommentStart) {
          inComment = 2;
        }
        if (inComment === 2 && result.length >= multiLineCommentEnd.length && result.substring((result.length).operators("-",multiLineCommentEnd.length), result.length) === multiLineCommentEnd) {
          inComment = 0;
        }
      }
      return result;
    };

    Shader.prototype.getName = function(name) {
      var pos;
      if (name == null) {
        name = this.name;
      }
      if ((pos = name.lastIndexOf(".")) !== -1) {
        name = name.substr(0, pos);
      }
      return name;
    };

    Shader.prototype.getPublicMangler = function(name) {
      var pos;
      if (name == null) {
        name = this.name;
      }
      if ((pos = name.lastIndexOf(".")) !== -1) {
        name = name.substr(0, pos);
      }
      name = name.replace(/\W+/, "_");
      return (("").operators("+",name)).operators("+","_");
    };

    Shader.prototype.getMangler = function() {
      var rand;
      rand = this.guid;
      return ((("").operators("+",rand)).operators("+","_")).operators("+",(this.getPublicMangler()));
    };

    Shader.prototype.mangle = function(currentSrc) {
      var mangle, mangledFunc, mangledName, mangledNames, mangledSignature, mangler, mangles, match, name, publicMangler, shaderName, src, variable, variableName, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
      src = this.src;
      publicMangler = this.getPublicMangler();
      mangler = this.getMangler();
      mangles = this.findFunctions();
      mangledNames = {};
      for (_i = 0, _len = mangles.length; _i < _len; _i++) {
        mangle = mangles[_i];
        if (mangle.typePublic) {
          mangledName = (publicMangler).operators("+",mangle.name);
        } else {
          mangledName = (mangler).operators("+",mangle.name);
        }
        mangledSignature = mangle.signature.replace(mangle.name, mangledName);
        mangledFunc = mangle.full.replace(mangle.signature, mangledSignature);
        mangledFunc = mangledFunc.replace(/public[\s\t\n]+/, '');
        src = src.replace(mangle.full, mangledFunc);
        mangledNames[mangle.name] = mangledName;
        if (mangle.name === "main") {
          this.main = mangledName;
        }
      }
      for (name in mangledNames) {
        if (!__hasProp.call(mangledNames, name)) continue;
        mangledName = mangledNames[name];
        while (match = new RegExp((("(^|\\W)").operators("+",name)).operators("+","(\\W|$)")).exec(src)) {
          src = src.replace(match[0], ((match[1]).operators("+",mangledName)).operators("+",match[2]));
        }
      }
      this.variables = {};
      shaderName = this.getName();
      mangles = this.findVariables();
      for (_j = 0, _len1 = mangles.length; _j < _len1; _j++) {
        mangle = mangles[_j];
        mangledNames = [];
        _ref = mangle.displayNames;
        for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
          name = _ref[_k];
          if (mangle.typeGlobal) {
            if (new RegExp((("").operators("+",name)).operators("+","(,|;)")).test(currentSrc)) {
              continue;
            }
            mangledName = name;
          } else if (mangle.typePublic) {
            mangledName = (publicMangler).operators("+",name);
          } else {
            mangledName = (mangler).operators("+",name);
          }
          mangledNames.push(mangledName);
          if ((_ref1 = mangle.typeQualifier) === 'uniform' || _ref1 === 'attribute') {
            if (mangle.typeGlobal) {
              variableName = name;
            } else {
              variableName = ((("").operators("+",shaderName)).operators("+",".")).operators("+",name);
            }
            this.variables[variableName] = {
              label: name,
              name: mangledName,
              type: mangle.type,
              qualifier: mangle.typeQualifier
            };
          }
        }
        if (mangledNames.length > 0) {
          mangledNames = mangledNames.join(', ');
          variable = [mangle.typeQualifier, mangle.type, mangledNames].join(' ');
          variable += ';';
        } else {
          variable = "";
        }
        if (mangle.typeGlobal) {
          src = ((variable).operators("+","\n")).operators("+",src);
          variable = "";
        }
        src = src.replace(mangle.match[0], variable);
        if (mangle.typeGlobal) {
          continue;
        }
        _ref2 = mangle.names;
        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
          name = _ref2[_l];
          if (mangle.typePublic) {
            mangledName = (publicMangler).operators("+",name);
          } else {
            mangledName = (mangler).operators("+",name);
          }
          while (match = new RegExp((("(^|\\W)").operators("+",name)).operators("+","(\\W|$)")).exec(src)) {
            src = src.replace(match[0], ((match[1]).operators("+",mangledName)).operators("+",match[2]));
          }
        }
      }
      return src;
    };

    Shader.prototype.activateMain = function() {
      var match, src;
      src = this.src;
      if (this.main) {
        while (match = new RegExp((("(^|\\W)").operators("+",this.main)).operators("+","(\\W|$)")).exec(src)) {
          src = src.replace(match[0], ((match[1]).operators("+","main")).operators("+",match[2]));
        }
        return this.src = src;
      }
    };

    Shader.prototype.mergeVariables = function(shaderSource) {
      var name, shaderName, variable, _ref;
      shaderName = shaderSource.getName();
      _ref = shaderSource.variables;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        variable = _ref[name];
        this.variables[name] = variable;
      }
      return this.variables;
    };

    Shader.prototype.mergeGlobals = function(shaderSource) {
      var global, _i, _len, _ref;
      _ref = shaderSource.globals;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        global = _ref[_i];
        if (global.name) {
          this.globals.push(global);
        }
      }
      return this.globals;
    };

    Shader.prototype.mergeImports = function(importedShader) {
      var imported, _i, _len, _ref;
      _ref = importedShader.imports;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        imported = _ref[_i];
        if (__indexOf.call(this.imports, imported) < 0) {
          this.imports.push(imported);
        }
      }
      return this.imports;
    };

    Shader.prototype.importShader = function(importInfo) {
      var global, imported, importedShader, posAfterBegin, posBeforeEnd, _i, _j, _len, _len1, _ref, _ref1, _ref2;
      if (_ref = importInfo.name, __indexOf.call(this.imports, _ref) >= 0) {
        this.src = this.src.replace(importInfo.match, '');
        return;
      }
      importedShader = new Shader(importInfo.name);
      _ref1 = this.imports;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        imported = _ref1[_i];
        importedShader.imports.push(imported);
      }
      _ref2 = this.globals;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        global = _ref2[_j];
        importedShader.globals.push(global);
      }
      posBeforeEnd = this.src.search(importInfo.match);
      posAfterBegin = (posBeforeEnd).operators("+",importInfo.match.length);
      importedShader.compile(false, this.src.substr(0, posBeforeEnd), this.src.substr(posAfterBegin));
      this.src = importedShader.getSource();
      this.mergeImports(importedShader);
      return this.mergeVariables(importedShader);
    };

    return Shader;

  })(Component);

}).call(this);
