// Generated by CoffeeScript 1.6.2
(function() {
  var Canvas, MatrixStack, Scene, livenUp,
    __hasProp = {}.hasOwnProperty,
    __operators = Object.prototype.operators = function(operator, object) { switch (operator) {case '+': return this + object;case '-': return this - object;case '/':return this / object;case '*':return this * object;case '%':return this % object;case '^':return this ^ object;default:throw SyntaxError('Object does not support "' + operator + '" operator');}},
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.Canvas = Canvas = (function() {
    var gl;

    gl = null;

    /*
    Livens up the given canvas element. Gets webgl context or display an error msg.
    Extends context object. Registers events. Sets WebGL constants available from 
    Enliven object. And finally enters into render loop.
    
    @param {DOMElement} element The canvas element
    @param {Object} options The options for the enliving canvas element. The 
      following options are available:
      * failover {string} - The name of the element to be showed whether WebGL context is not available
    */


    function Canvas(element, options) {
      var failoverInfo, name, value, _ref;
      this.element = element;
      this.options = options != null ? options : {};
      this.element.width = this.element.offsetWidth;
      this.element.height = this.element.offsetHeight;
      _ref = this.options;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        if (value === "0" || value === 0 || value === "false") {
          this.options[name] = false;
        } else if (value === "1" || value === 1 || value === "true") {
          this.options[name] = true;
        }
      }
      gl = this.getContext();
      if (this.options.failover != null) {
        failoverInfo = document.getElementById(this.options.failover);
        failoverInfo.style.display = "none";
        failoverInfo.className = this.element.className;
      }
      if (gl == null) {
        failoverInfo.style.display = "block";
        this.element.style.display = "none";
        return false;
      }
      this.gl = gl;
      this.extendContext(gl);
      this.constants();
      this.setupInputDevices();
      /*
      @element.onclick = (e) =>
        position = @getCanvasPosition()
        x = e.clientX - position.left
        y = @element.offsetHeight - (e.clientY - position.top)
        
        vec = @scene.camera.unproject x,y
              
        id = (@pickRegionalIndices x,y,x+1,y+1)
        if id.length > 0
          modelObj = @scene.getModel id[0]
      
          plane = modelObj.getWorldXYPlane()
          orign = vec[0]
          direction = (vec[1] - vec[0]).normalize()
          point = plane.intersectRayPoint orign, direction
          
          modelObj.setPosition point
      */

      this.keys = {};
      this.initKeyboardState();
      this.renderLoop();
    }

    Canvas.prototype.getCanvasPosition = function() {
      var obj, ol, ot;
      obj = this.element;
      ol = ot = 0;
      while (obj = obj.offsetParent) {
        ol += obj.offsetLeft;
        ot += obj.offsetTop;
      }
      return {
        left: ol,
        top: ot
      };
    };

    Canvas.prototype.initInput = function() {};

    Canvas.prototype.setupInputDevices = function(focusCanvas) {
      if (focusCanvas == null) {
        focusCanvas = true;
      }
      if (typeof Input !== "undefined" && Input !== null ? Input.Mouse : void 0) {
        return this.mouse = new Input.Mouse(this.element);
      }
    };

    Canvas.prototype.extendContext = function(gl) {
      var id;
      id = this.element.id;
      if (id !== "") {
        window.Enliven[id] = this;
      }
      gl.id = id;
      gl.canvas = this.element;
      gl.enliven = this;
      gl.viewportWidth = this.element.width;
      gl.viewportHeight = this.element.height;
      gl.matrixStack = new MatrixStack;
      return gl.scene = null;
    };

    Canvas.prototype.constants = function() {
      if (Enliven.gl == null) {
        return Enliven.gl = this.gl;
      }
    };

    Canvas.prototype.getContext = function() {
      var ex;
      if (gl !== null) {
        return gl;
      }
      if (this.element.getContext) {
        try {
          gl = this.element.getContext('webgl');
        } catch (_error) {
          ex = _error;
        }
        try {
          gl = this.element.getContext('experimental-webgl');
        } catch (_error) {
          ex = _error;
        }
      }
      return gl;
    };

    Canvas.prototype.resize = function(width, height) {
      gl.viewport(0, 0, width, height);
      gl.viewportWidth = width;
      return gl.viewportHeight = height;
    };

    Canvas.prototype.pickBuffer = null;

    Canvas.prototype.getPickBuffer = function(force) {
      if (force == null) {
        force = false;
      }
      if (this.pickBuffer !== null && !force) {
        return this.pickBuffer;
      }
      return this.pickBuffer = new Framebuffer({
        width: this.element.width,
        height: this.element.height
      });
    };

    Canvas.prototype.pickRegionalIndices = function(x1, y1, x2, y2) {
      var data, h, i, index, pickBuffer, result, w, _i, _ref;
      w = Math.abs((x2).operators("-",x1));
      h = Math.abs((y2).operators("-",y1));
      result = new Array();
      pickBuffer = this.getPickBuffer();
      data = new Uint8Array(((w).operators("*",h)).operators("*",4));
      gl = this.gl;
      pickBuffer.bind(gl);
      pickBuffer.viewport(gl);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.disable(gl.BLEND);
      this.render({
        picking: true
      });
      gl.readPixels(x1, y1, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);
      if (data.data) {
        data = data.data;
      }
      pickBuffer.unbind(gl);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.enable(gl.BLEND);
      for (i = _i = 0, _ref = data.length; _i <= _ref; i = _i += 4) {
        if (data[(i).operators("+",2)] > 0) {
          index = Enliven.decodePickingColor(data[i], data[(i).operators("+",1)], data[(i).operators("+",2)], data[(i).operators("+",3)]);
          if (index != null) {
            result.push(index);
          }
        }
      }
      return result;
    };

    Canvas.prototype.pickIndex = function(x, y) {
      return this.pickRegionalIndices(x, y, (x).operators("+",1), (y).operators("+",1))[0];
    };

    Canvas.prototype.initKeyboardState = function() {
      var _this = this;
      document.addEventListener('keydown', function(e) {
        return _this.keys[e.keyCode] = true;
      });
      return document.addEventListener('keyup', function(e) {
        return _this.keys[e.keyCode] = false;
      });
    };

    Canvas.prototype.render = function(options) {
      var _ref;
      if (options == null) {
        options = {};
      }
      return (_ref = this.scene) != null ? _ref.render(this.gl, options) : void 0;
    };

    Canvas.prototype.update = function(options) {
      var _ref;
      return (_ref = this.scene) != null ? _ref.update(this.gl, options) : void 0;
    };

    Canvas.prototype.setScene = function(sceneObject) {
      this.removeScene();
      gl.scene = this.scene = sceneObject;
      this.registerListeners();
      return this.scene.attach(gl);
    };

    Canvas.prototype.removeScene = function() {
      if (this.scene != null) {
        this.unregisterListeners();
        this.scene.detach(gl);
      }
      return this.scene = null;
    };

    Canvas.prototype.registerListeners = function() {
      var _this = this;
      if (!this.scene) {
        return;
      }
      if (this.mouse) {
        if (this.scene.mouse_pressed) {
          this.mouse.listen('press', function(evt) {
            return _this.scene.mouse_pressed(evt);
          });
        }
        if (this.scene.mouse_released) {
          this.mouse.listen('release', function(evt) {
            return _this.scene.mouse_released(evt);
          });
        }
        if (this.scene.mouse_clicked) {
          this.mouse.listen('click', function(evt) {
            return _this.scene.mouse_clicked(evt);
          });
        }
        if (this.scene.mouse_moved) {
          this.mouse.listen('move', function(evt) {
            return _this.scene.mouse_moved(evt);
          });
        }
        if (this.scene.mouse_entered) {
          this.mouse.listen('enter', function(evt) {
            return _this.scene.mouse_entered(evt);
          });
        }
        if (this.scene.mouse_exited) {
          this.mouse.listen('exit', function(evt) {
            return _this.scene.mouse_exited(evt);
          });
        }
        if (this.scene.mouse_dragged) {
          this.mouse.listen('drag', function(evt) {
            return _this.scene.mouse_dragged(evt);
          });
        }
        if (this.scene.mouse_rolled) {
          this.mouse.listen('wheel', function(evt) {
            return _this.scene.mouse_rolled(evt);
          });
        }
        if (this.scene.mouse_over) {
          this.mouse.listen('over', function(evt) {
            return _this.scene.mouse_over(evt);
          });
        }
      }
      if (this.keyboard) {
        if (this.scene.key_pressed) {
          this.keyboard.listen('press', function(evt) {
            return _this.scene.key_pressed(evt);
          });
        }
        if (this.scene.key_released) {
          this.keyboard.listen('release', function(evt) {
            return _this.scene.key_released(evt);
          });
        }
        if (this.scene.key_typed) {
          this.keyboard.listen('type', function(evt) {
            return _this.scene.key_typed(evt);
          });
        }
      }
      return true;
    };

    Canvas.prototype.unregisterListeners = function() {
      if (this.mouse) {
        this.mouse.stopListening();
      }
      if (this.keyboard) {
        return this.keyboard.stopListening();
      }
    };

    Canvas.prototype.renderLoop = function() {
      var frameCount, framesPerSecond, lastFpsTimeStamp, lastTimeStamp, nextFrame, startTime,
        _this = this;
      startTime = null;
      lastTimeStamp = startTime;
      lastFpsTimeStamp = startTime;
      framesPerSecond = 0;
      frameCount = 0;
      nextFrame = function(time) {
        if (startTime === null) {
          startTime = time;
        }
        window.requestAnimationFrame(nextFrame, _this.element);
        if (((time).operators("-",lastFpsTimeStamp)) >= 1000) {
          framesPerSecond = frameCount;
          frameCount = 0;
          lastFpsTimeStamp = time;
        }
        _this.update({
          startTime: startTime,
          timeStamp: time,
          elapsed: (time).operators("-",startTime),
          frameTime: (time).operators("-",lastTimeStamp),
          framesPerSecond: framesPerSecond
        });
        _this.render();
        ++frameCount;
        return lastTimeStamp = time;
      };
      return window.requestAnimationFrame(nextFrame, this.element);
    };

    return Canvas;

  })();

  window.Scene = Scene = (function(_super) {
    __extends(Scene, _super);

    function Scene() {
      this.models = [];
      this.lights = {};
      this.modelLabels = {};
      this.mvMatrixStack = [];
      this.options = {
        near: 0.1,
        far: 100.0
      };
      this.mvMatrix = new Mat4([]);
      this.pMatrix = new Mat4([]);
      this.camera = new Camera;
      this.init();
    }

    Scene.prototype.init = function() {};

    Scene.prototype.pushMvMatrix = function() {
      var copy;
      copy = this.mvMatrix.clone();
      this.mvMatrixStack.push(copy);
      return this.mvMatrix;
    };

    Scene.prototype.popMvMatrix = function() {
      if (this.mvMatrixStack.length === 0) {
        throw "Invalid popMatrix!";
      }
      return this.mvMatrix = this.mvMatrixStack.pop();
    };

    Scene.prototype.attach = function(gl, canvas) {
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      return gl.enable(gl.DEPTH_TEST);
    };

    Scene.prototype.dettach = function(gl, canvas) {};

    Scene.prototype.addLight = function(name, light) {
      return this.lights[name] = light;
    };

    Scene.prototype.getLight = function(name) {
      return this.lights[name];
    };

    Scene.prototype.removeLight = function(name) {
      return this.lights[name] = void 0;
    };

    Scene.prototype.addModel = function(modelObject, name) {
      if (name == null) {
        name = null;
      }
      this.models[modelObject.id] = modelObject;
      if (name !== null) {
        return this.modelLabels[name] = modelObject;
      }
    };

    Scene.prototype.removeModel = function(id) {
      if (__indexOf.call(this.models, id) < 0) {
        return false;
      }
      delete this.models[id];
      return true;
    };

    Scene.prototype.getModelId = function(name) {
      var _ref;
      return (_ref = this.modelLabels[name]) != null ? _ref : null;
    };

    Scene.prototype.getModel = function(name) {
      var id;
      if (name instanceof String) {
        id = getModelId(name);
      } else {
        id = name;
      }
      if (id in this.models) {
        return this.models[id];
      }
      return null;
    };

    Scene.prototype.getModels = function() {
      return this.models;
    };

    Scene.prototype.setCamera = function(camera) {
      this.camera = camera;
    };

    Scene.prototype.getPMatrix = function(gl) {
      if (this.camera !== null) {
        return this.camera.getProjectionMatrix();
      } else {
        return new Mat4([]).setPerspective(45, (gl.viewportWidth).operators("/",gl.viewportHeight), this.options.near, this.options.far);
      }
    };

    /*
    Reloads and resets the matrix stack. Meant to be called
    each frame, prior to rendering the scene. This is called
    by #render automatically. Returns the stack itself.
    */


    Scene.prototype.reloadMatrices = function(gl) {
      var camera, matrixStack;
      matrixStack = gl.matrixStack;
      camera = this.camera;
      matrixStack.reset();
      matrixStack.loadModelMatrix(new Mat4([]).setIdentity());
      matrixStack.loadViewMatrix(camera.getInverseTransformationMatrix());
      matrixStack.loadProjectionMatrix(camera.getProjectionMatrix());
      return matrixStack;
    };

    Scene.prototype.prepare = function(gl, options) {
      this.reloadMatrices(gl);
      gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
      return gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };

    Scene.prototype.render = function(gl, options) {
      var i, modelObj, _ref, _results;
      this.prepare(gl, options);
      this.pMatrix = gl.matrixStack.getProjectionMatrix();
      this.mvMatrix = gl.matrixStack.getModelViewMatrix();
      _ref = this.getModels();
      _results = [];
      for (i in _ref) {
        if (!__hasProp.call(_ref, i)) continue;
        modelObj = _ref[i];
        _results.push(modelObj.render(gl, options, this));
      }
      return _results;
    };

    Scene.prototype.update = function(gl, options) {
      var i, modelObj, _ref, _results;
      _ref = this.getModels();
      _results = [];
      for (i in _ref) {
        if (!__hasProp.call(_ref, i)) continue;
        modelObj = _ref[i];
        _results.push(modelObj.update(gl, options, this));
      }
      return _results;
    };

    return Scene;

  })(Component);

  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = (function() {
      return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
        return window.setTimeout(function() {
          return callback(new Date().getTime());
        }, (1000).operators("/",60));
      };
    })();
  }

  MatrixStack = (function() {
    function MatrixStack() {
      this.maxDepth = 0;
      this.matrices = {
        model: [new Mat4([])],
        view: [new Mat4([])],
        modelView: [new Mat4([])],
        projection: [new Mat4([])]
      };
      this.valid = {
        modelView: [true]
      };
      this.reset();
    }

    MatrixStack.prototype.reset = function() {
      return this.depth = 0;
    };

    MatrixStack.prototype.push = function() {
      var stack, type, _ref, _ref1;
      this.depth++;
      if (this.depth > this.maxDepth) {
        _ref = this.matrices;
        for (type in _ref) {
          if (!__hasProp.call(_ref, type)) continue;
          stack = _ref[type];
          while (stack.length <= this.depth) {
            stack.push(stack[(stack.length).operators("-",1)].clone());
          }
        }
        _ref1 = this.valid;
        for (type in _ref1) {
          if (!__hasProp.call(_ref1, type)) continue;
          stack = _ref1[type];
          while (stack.length <= this.depth) {
            stack.push(stack[(stack.length).operators("-",1)]);
          }
        }
        this.maxDepth = this.depth;
      }
      this.loadModelMatrix(this.matrices.model[(this.depth).operators("-",1)]);
      this.loadViewMatrix(this.matrices.view[(this.depth).operators("-",1)]);
      return this.loadProjectionMatrix(this.matrices.projection[(this.depth).operators("-",1)]);
    };

    MatrixStack.prototype.pop = function() {
      if (this.depth > 0) {
        return this.depth--;
      }
    };

    /*
    Replaces the current model matrix with the specified one.
    Updates the inverse model matrix, the modelview matrix, the inverse modelview matrix and the
    normal matrix.
    */


    MatrixStack.prototype.loadModelMatrix = function(other) {
      this.valid.modelView[this.depth] = false;
      return other.copyTo(this.getModelMatrix());
    };

    /*
    Replaces the current view matrix with the specified one.
    Updates the inverse view matrix, the modelview matrix, the inverse modelview matrix and the
    normal matrix.
    */


    MatrixStack.prototype.loadViewMatrix = function(other) {
      this.valid.modelView[this.depth] = false;
      return other.copyTo(this.getViewMatrix());
    };

    /*
    Replaces the current projection matrix with the specified one.
    Updates the inverse projection matrix.
    */


    MatrixStack.prototype.loadProjectionMatrix = function(other) {
      return other.copyTo(this.getProjectionMatrix());
    };

    MatrixStack.prototype.multModelMatrix = function(other) {
      this.valid.modelView[this.depth] = false;
      return this.getModelMatrix().multiplyBy(other);
    };

    /*
    The local model transformation matrix. Most models will manipulate this matrix.
    Multiplying an object-space coordinate by this matrix will result in a world-space coordinate.
    */


    MatrixStack.prototype.getModelMatrix = function() {
      return this.matrices.model[this.depth];
    };

    /*
    AKA the camera matrix. Multiplying a point in world space against the view matrix
    results in a point in eye space (e.g. relative to the eye, with the eye at the origin).
    */


    MatrixStack.prototype.getViewMatrix = function() {
      return this.matrices.view[this.depth];
    };

    /*
    AKA the screen matrix. Multiplying a point in eye space against the projection matrix results in a 4D
    vector in clip space. Dividing clip coordinates (XYZ) by the 4th component (W) yields a 3D vector in
    normalized device coordinates, where all components are in the range [-1,1]. These points are ultimately
    multiplied by screen dimensions to find a pixel position.
    */


    MatrixStack.prototype.getProjectionMatrix = function() {
      return this.matrices.projection[this.depth];
    };

    /*
    A combination of both model and view
    matrices, equivalent to mat4.multiply(view, model).
    
    Multiplying a point in object space by this matrix will effectively skip the world space transformation,
    resulting in a coordinate placed directly into eye space. This has the obvious advantage of being faster
    than performing the operation in two steps (model and then view).
    */


    MatrixStack.prototype.getModelViewMatrix = function() {
      if (this.valid.modelView[this.depth]) {
        return this.matrices.modelView[this.depth];
      } else {
        this.valid.modelView[this.depth] = true;
        return this.matrices.modelView[this.depth] = (this.getViewMatrix()).operators("*",this.getModelMatrix());
      }
    };

    return MatrixStack;

  })();

  livenUp = function() {
    var canvasElements, element, event, i, options, _i, _j, _len, _ref;
    canvasElements = window.document.getElementsByTagName('canvas');
    for (_i = 0, _len = canvasElements.length; _i < _len; _i++) {
      element = canvasElements[_i];
      if (element.getAttribute("data-enliven") === "true") {
        options = {};
        for (i = _j = 0, _ref = (element.attributes.length).operators("-",1); 0 <= _ref ? _j <= _ref : _j >= _ref; i = 0 <= _ref ? ++_j : --_j) {
          if (element.attributes[i].nodeName.indexOf("data-") === 0) {
            options[element.attributes[i].nodeName.substr(5)] = element.attributes[i].nodeValue;
          }
        }
        if (options.enliven) {
          element.enliven = new Canvas(element, options);
        }
      }
    }
    event = new CustomEvent('enliven');
    return this.dispatchEvent(event);
  };

  if (window.addEventListener) {
    window.addEventListener('DOMContentLoaded', livenUp, false);
  } else {
    window.attachEvent('onload', livenUp);
  }

  if (document.readyState === 'complete') {
    livenUp();
  }

}).call(this);
