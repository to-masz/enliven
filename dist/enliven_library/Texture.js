// Generated by CoffeeScript 1.6.2
(function() {
  var Texture,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __operators = Object.prototype.operators = function(operator, object) { switch (operator) {case '+': return this + object;case '-': return this - object;case '/':return this / object;case '*':return this * object;case '%':return this % object;case '^':return this ^ object;default:throw SyntaxError('Object does not support "' + operator + '" operator');}};

  window.Texture = Texture = (function(_super) {
    __extends(Texture, _super);

    Texture.prototype.initialized = false;

    Texture.prototype.valid = [];

    Texture.prototype.options = {};

    Texture.prototype.isPoT = function(s) {
      return s && (s & -s) === s;
    };

    function Texture(file, options) {
      var name, value,
        _this = this;
      this.file = file;
      for (name in options) {
        if (!__hasProp.call(options, name)) continue;
        value = options[name];
        this.options[name] = value;
      }
      if (this.file) {
        this.image = new Image();
        this.image.onload = function(e) {
          var _ref;
          if (!_this.isPoT(_this.image.width || !_this.isPoT(_this.image.height))) {
            _this.options.mag_filter = Enliven.gl.LINEAR;
            _this.options.min_filter = Enliven.gl.LINEAR;
            _this.options.wrap_s = Enliven.gl.CLAMP_TO_EDGE;
            _this.options.wrap_t = Enliven.gl.CLAMP_TO_EDGE;
            _this.options.generate_mipmap = false;
          }
          if ((_ref = _this.options.onload) != null) {
            _ref.call(_this, _this.image);
          }
          return _this.initialized = true;
        };
        this.image.onerror = this.image.onabort = function(e) {
          throw new Error((("Failed to load '").operators("+",_this.image.src)).operators("+","' texture."));
        };
        this.image.src = this.file;
      } else {
        this.initialized = true;
      }
    }

    Texture.prototype.generateTexture = function(gl) {
      var data_type, format, height, target, ti2d, width;
      data_type = this.options.data_type;
      format = this.options.format;
      target = this.options.target;
      if (this.image) {
        return gl.texImage2D(target, 0, format, format, data_type, this.image);
      } else {
        width = this.options.width;
        height = this.options.height;
        if (!width || !height) {
          throw new Error("Can't build an empty texture without at least a width and height");
        }
        ti2d = function(glEnum) {
          var e, tex;
          try {
            return gl.texImage2D(glEnum, 0, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);
          } catch (_error) {
            e = _error;
            tex = new Uint8Array(((width).operators("*",height)).operators("*",Enliven.sizeofFormat(format)));
            return gl.texImage2D(glEnum, 0, format, width, height, 0, format, gl.UNSIGNED_BYTE, tex);
          }
        };
        return ti2d(gl.TEXTURE_2D);
      }
    };

    Texture.prototype.generateMipmap = function(gl) {
      return gl.generateMipmap(this.options.target);
    };

    Texture.prototype.build = function(gl) {
      return this.setHandle(gl, gl.createTexture());
    };

    Texture.prototype.refresh = function(gl) {
      var colorspaceConversion, name, options, texture, value;
      if (!this.initialized) {
        return false;
      }
      options = {
        min_filter: gl.NEAREST,
        mag_filter: gl.NEAREST,
        generate_mipmap: true,
        mipmap_hint: gl.DONT_CARE,
        format: gl.RGBA,
        target: gl.TEXTURE_2D,
        data_type: gl.UNSIGNED_BYTE,
        wrap_s: gl.REPEAT,
        wrap_t: gl.REPEAT,
        flip_y: false,
        premultiply_alpha: false,
        colorspace_conversion: true,
        onload: null
      };
      for (name in options) {
        if (!__hasProp.call(options, name)) continue;
        value = options[name];
        if (this.options[name] === void 0) {
          this.options[name] = value;
        }
      }
      texture = this.getHandle(gl);
      gl.bindTexture(this.options.target, texture);
      this.setHandle(gl, texture);
      this.generateTexture(gl);
      gl.texParameteri(this.options.target, gl.TEXTURE_MAG_FILTER, this.options.mag_filter);
      gl.texParameteri(this.options.target, gl.TEXTURE_MIN_FILTER, this.options.min_filter);
      gl.texParameteri(this.options.target, gl.TEXTURE_WRAP_S, this.options.wrap_s);
      gl.texParameteri(this.options.target, gl.TEXTURE_WRAP_T, this.options.wrap_t);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.options.flip_y);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.options.premultiply_alpha);
      colorspaceConversion = gl.NONE;
      if (this.options.colorspace_conversion) {
        colorspaceConversion = gl.BROWSER_DEFAULT_WEBGL;
      }
      gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, colorspaceConversion);
      if (this.options.generate_mipmap) {
        this.generateMipmap(gl);
      }
      gl.bindTexture(this.options.target, null);
      return this.valid[gl.id] = true;
    };

    Texture.prototype.isValid = function(gl) {
      var _ref;
      return (_ref = this.valid[gl.id]) != null ? _ref : false;
    };

    Texture.prototype.bind = function(gl) {
      if (!this.initialized) {
        return null;
      }
      if (!this.isValid(gl)) {
        this.refresh(gl);
      }
      gl.activeTexture(gl.TEXTURE0);
      return gl.bindTexture(this.options.target, this.getHandle(gl));
    };

    Texture.prototype.unbind = function(gl) {
      if (this.isValid(gl)) {
        return gl.bindTexture(this.options.target, null);
      }
    };

    Texture.prototype.getHandle = function(gl) {
      if ((this.contexts == null) || (this.contexts[gl.id] == null)) {
        this.build(gl);
        this.refresh(gl);
      }
      return this.contexts[gl.id];
    };

    return Texture;

  })(Component);

  /*   
   init: (gl) ->
     gl.bindTexture(gl.TEXTURE_2D, @texture);
     gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, @image);
     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
     gl.bindTexture(gl.TEXTURE_2D, null);
     
   apply: (gl, material) ->
     if @texture is null
       @texture = gl.createTexture();
     
     if @initialized
       @init gl
       @initialized = false
       
     gl.activeTexture(gl.TEXTURE0);
     gl.bindTexture(gl.TEXTURE_2D, @texture);
     material.applyMaterial gl, {
       "uSampler", 0
     }
  */


}).call(this);
