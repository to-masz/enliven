// Generated by CoffeeScript 1.6.2
(function() {
  var ShaderProgram,
    __hasProp = {}.hasOwnProperty,
    __operators = Object.prototype.operators = function(operator, object) { switch (operator) {case '+': return this + object;case '-': return this - object;case '/':return this / object;case '*':return this * object;case '%':return this % object;case '^':return this ^ object;default:throw SyntaxError('Object does not support "' + operator + '" operator');}};

  window.ShaderProgram = ShaderProgram = (function() {
    ShaderProgram.current = null;

    function ShaderProgram(name) {
      this.name = name;
      this.reset();
    }

    ShaderProgram.prototype.reset = function() {
      this.shaderProgram = null;
      this.vertexShader = null;
      return this.fragmentShader = null;
    };

    ShaderProgram.prototype.use = function(gl) {
      var program;
      program = this.getShaderProgram(gl);
      ShaderProgram.current = this;
      return gl.useProgram(program);
    };

    ShaderProgram.prototype.setOptions = function(options) {
      var name, value, _results;
      _results = [];
      for (name in options) {
        if (!__hasProp.call(options, name)) continue;
        value = options[name];
        _results.push(this[name] = value);
      }
      return _results;
    };

    ShaderProgram.prototype.bindProperties = function(gl, properties) {
      var name, value, _results;
      _results = [];
      for (name in properties) {
        if (!__hasProp.call(properties, name)) continue;
        value = properties[name];
        _results.push(this.bindProperty(gl, name, value));
      }
      return _results;
    };

    ShaderProgram.prototype.bindProperty = function(gl, name, value) {
      var n, property, shaderProgram, v;
      if (typeof value === 'Object' && !(value instanceof Array)) {
        for (n in value) {
          if (!__hasProp.call(value, n)) continue;
          v = value[n];
          this.bindProperty(gl(((("").operators("+",name)).operators("+",".")).operators("+",n), v));
        }
        return true;
      }
      shaderProgram = this.getShaderProgram(gl);
      if (!(name in shaderProgram.properties && value !== void 0)) {
        return false;
      }
      property = shaderProgram.properties[name];
      switch (property.qualifier) {
        case "uniform":
          if (value instanceof BaseMatrix) {
            value = value.elements;
          }
          switch (property.type) {
            case 'float':
              return gl.uniform1f(property.location, value);
            case 'bool':
            case 'int':
              return gl.uniform1i(property.location, value);
            case 'vec2':
              return gl.uniform2fv(property.location, value);
            case 'vec3':
              return gl.uniform3fv(property.location, value);
            case 'vec4':
              return gl.uniform4fv(property.location, value);
            case 'bvec2':
            case 'ivec2':
              return gl.uniform2iv(property.location, value);
            case 'bvec3':
            case 'ivec3':
              return gl.uniform3iv(property.location, value);
            case 'bvec4':
            case 'ivec4':
              return gl.uniform4iv(property.location, value);
            case 'mat2':
              return gl.uniformMatrix2fv(property.location, false, value);
            case 'mat3':
              return gl.uniformMatrix3fv(property.location, false, value);
            case 'mat4':
              return gl.uniformMatrix4fv(property.location, false, value);
            case 'sampler2D':
            case 'samplerCube':
              return gl.uniform1i(property.location, value);
            default:
              throw new Error(("Unexpected variable type: ").operators("+",property.type));
          }
          /*
          switch property.type
            when "mat4"
              gl.uniformMatrix4fv(property.location, false, value);
            when "sampler2D"
              gl.uniform1i property.location, 0
            when "float"
              gl.uniform1f property.location, value
          */

          break;
        case "attribute":
          return this.bindBuffer(gl, property, value);
      }
    };

    ShaderProgram.prototype.bindBuffer = function(gl, property, value) {
      var buffer, hash;
      if (value instanceof WebGLBuffer) {
        buffer = value;
      } else if ((value.hash != null) && this.buffers[value.hash] instanceof WebGLBuffer) {
        buffer = this.buffers[value.hash];
      } else {
        if (value instanceof Matrix) {
          value = value.elements;
        }
        hash = this.getArrayHash(value);
        value.hash = hash;
        if (this.buffers[hash] instanceof WebGLBuffer) {
          buffer = this.buffers[hash];
        } else {
          buffer = this.buffers[hash] = this.createPropertyBuffer(gl, property, value);
        }
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      return gl.vertexAttribPointer(property.location, buffer.itemSize, gl.FLOAT, false, 0, 0);
    };

    ShaderProgram.prototype.getArrayHash = function(value) {
      var c, hash, i, str, _i, _ref;
      hash = 0;
      str = JSON.stringify(value);
      if (str.length === 0) {
        return hash;
      }
      for (i = _i = 0, _ref = (str.length).operators("-",1); 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        c = str.charCodeAt(i);
        hash = ((((hash << 5)).operators("-",hash))).operators("+",c);
        hash |= 0;
      }
      return hash;
    };

    ShaderProgram.prototype.buffers = {};

    ShaderProgram.prototype.createPropertyBuffer = function(gl, property, value) {
      var buffer, result, size;
      result = /(mat|vec)([0-9])/.exec(property.type);
      size = result[2];
      switch (result[1]) {
        case "vec":
          buffer = ShaderProgram.createBuffer(gl, value, size);
          break;
        default:
          throw "Unsupported buffer type";
      }
      return buffer;
    };

    ShaderProgram.createBuffer = function(gl, data, size, dataType, type) {
      var buffer;
      if (size == null) {
        size = 3;
      }
      if (dataType == null) {
        dataType = Float32Array;
      }
      if (type == null) {
        type = gl.ARRAY_BUFFER;
      }
      buffer = gl.createBuffer();
      gl.bindBuffer(type, buffer);
      gl.bufferData(type, new dataType(data), gl.STATIC_DRAW);
      buffer.itemSize = size;
      buffer.numItems = (data.length).operators("/",size);
      return buffer;
    };

    ShaderProgram.prototype.getShaderProgram = function(gl, recompile) {
      if (recompile == null) {
        recompile = false;
      }
      if (recompile || this.shaderProgram === null) {
        this.shaderProgram = this.createShaderProgram(gl);
      }
      return this.shaderProgram;
    };

    ShaderProgram.prototype.getVertexShader = function() {
      if (this.vertexShader === null) {
        this.vertexShader = new Shader((("").operators("+",this.name)).operators("+",".vertex"));
      }
      return this.vertexShader;
    };

    ShaderProgram.prototype.getFragmentShader = function() {
      if (this.fragmentShader === null) {
        this.fragmentShader = new Shader((("").operators("+",this.name)).operators("+",".fragment"));
      }
      return this.fragmentShader;
    };

    ShaderProgram.prototype.createShaderProgram = function(gl) {
      var fragmentShader, fs, name, shaderParser, shaderProgram, variable, vertexShader, vs, _i, _len, _ref, _ref1;
      vertexShader = ("precision mediump float;\n\n").operators("+",(this.getVertexShader().getSource()));
      fragmentShader = ("precision mediump float;\n\n").operators("+",(this.getFragmentShader().getSource()));
      shaderProgram = gl.createProgram();
      vs = this.compileShader(gl, vertexShader, gl.VERTEX_SHADER);
      fs = this.compileShader(gl, fragmentShader, gl.FRAGMENT_SHADER);
      gl.attachShader(shaderProgram, vs);
      gl.attachShader(shaderProgram, fs);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        console.debug(gl.getProgramInfoLog(shaderProgram));
        gl.deleteProgram(shaderProgram);
        gl.deleteShader(vs);
        gl.deleteShader(fs);
        return null;
      }
      gl.useProgram(shaderProgram);
      shaderProgram.properties = {};
      _ref = [this.vertexShader, this.fragmentShader];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        shaderParser = _ref[_i];
        _ref1 = shaderParser.variables;
        for (name in _ref1) {
          if (!__hasProp.call(_ref1, name)) continue;
          variable = _ref1[name];
          shaderProgram.properties[name] = variable;
          shaderProgram.properties[name].locationName = name;
          switch (variable.qualifier) {
            case "attribute":
              shaderProgram.properties[name].location = gl.getAttribLocation(shaderProgram, variable.name);
              gl.enableVertexAttribArray(shaderProgram.properties[name].location);
              break;
            case "uniform":
              shaderProgram.properties[name].location = gl.getUniformLocation(shaderProgram, variable.name);
          }
        }
      }
      return shaderProgram;
    };

    ShaderProgram.prototype.compileShader = function(gl, source, type) {
      var glShader;
      glShader = gl.createShader(type);
      gl.shaderSource(glShader, source);
      gl.compileShader(glShader);
      if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
        console.debug(gl.getShaderInfoLog(glShader));
        gl.deleteShader(glShader);
        return null;
      }
      return glShader;
    };

    return ShaderProgram;

  })();

}).call(this);
