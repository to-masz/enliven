// Generated by CoffeeScript 1.6.2
(function() {
  var CuboidMesh, Mesh, PyramidMesh, SphereMesh, SquareMesh,
    __operators = Object.prototype.operators = function(operator, object) { switch (operator) {case '+': return this + object;case '-': return this - object;case '/':return this / object;case '*':return this * object;case '%':return this % object;case '^':return this ^ object;default:throw SyntaxError('Object does not support "' + operator + '" operator');}},
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  window.Mesh = Mesh = (function() {
    function Mesh() {
      this.vertexPositions = [];
      this.vertexColors = [];
      this.vertexIndices = null;
      this.vertexTextureCoords = [];
      this.vertexNormals = null;
      this.buffers = null;
      this.drawMode = 'GL_TRIANGLES';
      this.material = 'default';
      this._bounds = {
        left: new Vec3([]),
        right: new Vec3([]),
        top: new Vec3([]),
        bottom: new Vec3([]),
        front: new Vec3([]),
        back: new Vec3([]),
        center: new Vec3([]),
        width: 0,
        height: 0,
        depth: 0,
        radius: 0
      };
      this.init();
      this.recalculateBounds();
    }

    Mesh.prototype.init = function() {};

    Mesh.prototype.getBuffers = function(gl) {
      if (this.buffers === null) {
        this.initBuffers(gl);
      }
      return this.buffers;
    };

    Mesh.prototype.initBuffers = function(gl) {
      return this.buffers = {
        vertexPositionBuffer: this.createArrayBuffer(gl, this.vertexPositions),
        vertexNormalBuffer: this.createArrayBuffer(gl, this.vertexNormals),
        vertexColorBuffer: this.createArrayBuffer(gl, this.vertexColors, 4),
        vertexIndexBuffer: this.createArrayBuffer(gl, this.vertexIndices, 1, Uint16Array, gl.ELEMENT_ARRAY_BUFFER),
        vertexTextureCoordBuffer: this.createArrayBuffer(gl, this.vertexTextureCoords, 2)
      };
    };

    Mesh.prototype.createArrayBuffer = function(gl, vertices, size, dataType, type) {
      var buffer;
      if (size == null) {
        size = 3;
      }
      if (dataType == null) {
        dataType = Float32Array;
      }
      if (type == null) {
        type = gl.ARRAY_BUFFER;
      }
      if (vertices === null) {
        return null;
      }
      buffer = gl.createBuffer();
      gl.bindBuffer(type, buffer);
      gl.bufferData(type, new dataType(vertices), gl.STATIC_DRAW);
      buffer.itemSize = size;
      buffer.numItems = (vertices.length).operators("/",size);
      return buffer;
    };

    Mesh.prototype.render = function(gl, object, material) {
      var buffers;
      buffers = this.getBuffers(gl);
      material.apply(gl, object, this);
      if (buffers.vertexIndexBuffer !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.vertexIndexBuffer);
        gl.drawElements(gl.TRIANGLES, buffers.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
      } else {
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, buffers.vertexPositionBuffer.numItems);
      }
      return material.remove(gl, object, this);
    };

    Mesh.prototype.recalculateBounds = function() {
      var back, biggest, bottom, center, depth, front, height, i, left, position, right, top, width, _i, _ref, _ref1, _ref2;
      _ref = [this._bounds.left, this._bounds.right, this._bounds.top, this._bounds.bottom, this._bounds.front, this._bounds.back, this._bounds.center], left = _ref[0], right = _ref[1], top = _ref[2], bottom = _ref[3], front = _ref[4], back = _ref[5], center = _ref[6];
      position = new Vec3([]);
      biggest = 0;
      for (i = _i = 0, _ref1 = (this.vertexPositions.length).operators("-",1); _i < _ref1; i = _i += 3) {
        position.e(0, this.vertexPositions[i]);
        position.e(1, this.vertexPositions[(i).operators("+",1)]);
        position.e(2, this.vertexPositions[(i).operators("+",2)]);
        if (i === 0) {
          position.copyTo(left);
          position.copyTo(right);
          position.copyTo(top);
          position.copyTo(bottom);
          position.copyTo(front);
          position.copyTo(back);
        } else {
          if (position.e(0) < left.e(0)) {
            position.copyTo(left);
          }
          if (position.e(0) > right.e(0)) {
            position.copyTo(right);
          }
          if (position.e(1) < bottom.e(1)) {
            position.copyTo(bottom);
          }
          if (position.e(1) > top.e(1)) {
            position.copyTo(top);
          }
          if (position.e(2) < back.e(2)) {
            position.copyTo(back);
          }
          if (position.e(2) > front.e(2)) {
            position.copyTo(front);
          }
        }
      }
      width = (right.e(0)).operators("-",left.e(0));
      height = (top.e(1)).operators("-",bottom.e(1));
      depth = (front.e(2)).operators("-",back.e(2));
      biggest = (width > height && width > depth ? width : height > depth ? height : depth);
      center.e(0, (left.e(0)).operators("+",(width).operators("*",0.5)));
      center.e(1, (bottom.e(1)).operators("+",(height).operators("*",0.5)));
      center.e(2, (back.e(2)).operators("+",(depth).operators("*",0.5)));
      if (width < 0.0001) {
        width = 0.0001;
      }
      if (height < 0.0001) {
        height = 0.0001;
      }
      if (depth < 0.0001) {
        depth = 0.0001;
      }
      _ref2 = [width, height, depth], this._bounds.width = _ref2[0], this._bounds.height = _ref2[1], this._bounds.depth = _ref2[2];
      this._bounds.radius = (biggest).operators("/",2);
      return this._bounds;
    };

    Mesh.prototype.getBounds = function() {
      var copy, name, value, _ref;
      copy = {};
      _ref = this._bounds;
      for (name in _ref) {
        if (!__hasProp.call(_ref, name)) continue;
        value = _ref[name];
        copy[name] = value;
      }
      return copy;
    };

    return Mesh;

  })();

  window.CuboidMesh = CuboidMesh = (function(_super) {
    __extends(CuboidMesh, _super);

    function CuboidMesh(width, height, depth) {
      this.width = width != null ? width : 1;
      this.height = height != null ? height : 1;
      this.depth = depth != null ? depth : 1;
      CuboidMesh.__super__.constructor.apply(this, arguments);
    }

    CuboidMesh.prototype.init = function() {
      var color, colors, depth, height, i, j, unpackedColors, width, _i;
      depth = (this.depth).operators("/",2);
      height = (this.height).operators("/",2);
      width = (this.width).operators("/",2);
      this.vertexPositions = [-width, -height, depth, width, -height, depth, width, height, depth, -width, height, depth, -width, -height, -depth, -width, height, -depth, width, height, -depth, width, -height, -depth, -width, height, -depth, -width, height, depth, width, height, depth, width, height, -depth, -width, -height, -depth, width, -height, -depth, width, -height, depth, -width, -height, depth, width, -height, -depth, width, height, -depth, width, height, depth, width, -height, depth, -width, -height, -depth, -width, -height, depth, -width, height, depth, -width, height, -depth];
      colors = [[1.0, 0.0, 0.0, 1.0], [1.0, 1.0, 0.0, 1.0], [0.0, 1.0, 0.0, 1.0], [1.0, 0.5, 0.5, 1.0], [1.0, 0.0, 1.0, 1.0], [0.0, 0.0, 1.0, 1.0]];
      unpackedColors = [];
      for (i in colors) {
        if (!__hasProp.call(colors, i)) continue;
        color = colors[i];
        for (j = _i = 0; _i <= 3; j = ++_i) {
          unpackedColors = unpackedColors.concat(color);
        }
      }
      this.vertexColors = unpackedColors;
      this.vertexIndices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
      this.vertexTextureCoords = [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0];
      return this.vertexNormals = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0];
    };

    return CuboidMesh;

  })(Mesh);

  window.SphereMesh = SphereMesh = (function(_super) {
    __extends(SphereMesh, _super);

    function SphereMesh(radius, latitudeBands, longitudeBands) {
      this.radius = radius;
      this.latitudeBands = latitudeBands != null ? latitudeBands : 30;
      this.longitudeBands = longitudeBands != null ? longitudeBands : 30;
      SphereMesh.__super__.constructor.apply(this, arguments);
    }

    SphereMesh.prototype.init = function() {
      var cosPhi, cosTheta, first, latNumber, longNumber, phi, second, sinPhi, sinTheta, theta, u, v, x, y, z, _i, _j, _k, _ref, _ref1, _ref2, _results;
      this.vertexNormals = [];
      for (latNumber = _i = 0, _ref = this.latitudeBands; 0 <= _ref ? _i <= _ref : _i >= _ref; latNumber = 0 <= _ref ? ++_i : --_i) {
        theta = ((latNumber).operators("*",Math.PI)).operators("/",this.latitudeBands);
        sinTheta = Math.sin(theta);
        cosTheta = Math.cos(theta);
        for (longNumber = _j = 0, _ref1 = this.longitudeBands; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; longNumber = 0 <= _ref1 ? ++_j : --_j) {
          phi = (((longNumber).operators("*",2)).operators("*",Math.PI)).operators("/",this.longitudeBands);
          sinPhi = Math.sin(phi);
          cosPhi = Math.cos(phi);
          x = (cosPhi).operators("*",sinTheta);
          y = cosTheta;
          z = (sinPhi).operators("*",sinTheta);
          u = (1).operators("-",((longNumber).operators("/",this.longitudeBands)));
          v = (1).operators("-",((latNumber).operators("/",this.latitudeBands)));
          this.vertexNormals.push(x);
          this.vertexNormals.push(y);
          this.vertexNormals.push(z);
          this.vertexTextureCoords.push(u);
          this.vertexTextureCoords.push(v);
          this.vertexPositions.push((this.radius).operators("*",x));
          this.vertexPositions.push((this.radius).operators("*",y));
          this.vertexPositions.push((this.radius).operators("*",z));
        }
      }
      this.vertexIndices = [];
      _results = [];
      for (latNumber = _k = 0, _ref2 = (this.latitudeBands).operators("-",1); 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; latNumber = 0 <= _ref2 ? ++_k : --_k) {
        _results.push((function() {
          var _l, _ref3, _results1;
          _results1 = [];
          for (longNumber = _l = 0, _ref3 = (this.longitudeBands).operators("-",1); 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; longNumber = 0 <= _ref3 ? ++_l : --_l) {
            first = (((latNumber).operators("*",((this.longitudeBands).operators("+",1))))).operators("+",longNumber);
            second = ((first).operators("+",this.longitudeBands)).operators("+",1);
            this.vertexIndices.push(first);
            this.vertexIndices.push(second);
            this.vertexIndices.push((first).operators("+",1));
            this.vertexIndices.push(second);
            this.vertexIndices.push((second).operators("+",1));
            _results1.push(this.vertexIndices.push((first).operators("+",1)));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return SphereMesh;

  })(Mesh);

  window.PyramidMesh = PyramidMesh = (function(_super) {
    __extends(PyramidMesh, _super);

    function PyramidMesh(width, height, depth) {
      this.width = width != null ? width : 1;
      this.height = height != null ? height : 1;
      this.depth = depth != null ? depth : 1;
      PyramidMesh.__super__.constructor.apply(this, arguments);
    }

    PyramidMesh.prototype.init = function() {
      var depth, height, width;
      depth = (this.depth).operators("/",2);
      height = (this.height).operators("/",2);
      width = (this.width).operators("/",2);
      this.vertexPositions = [0.0, height, 0.0, -width, -height, depth, width, -height, depth, 0.0, height, 0.0, width, -height, depth, width, -height, -depth, 0.0, height, 0.0, width, -height, -depth, -width, -height, -depth, 0.0, height, 0.0, -width, -height, -depth, -width, -height, depth];
      return this.vertexColors = [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 1.0];
      /*
      @vertexIndices = [
        0, 1, 2,      0, 2, 3,    # Front face
        4, 5, 6,      4, 6, 7,    # Back face
        8, 9, 10,     8, 10, 11,  # Top face
        12, 13, 14,   12, 14, 15, # Bottom face
        16, 17, 18,   16, 18, 19, # Right face
        20, 21, 22,   20, 22, 23  # Left face
      ]
      
      @vertexTextureCoords = [
        # Front face
        0.0, 0.0,
        1.0, 0.0,
        1.0, 1.0,
        0.0, 1.0,
      
        # Back face
        1.0, 0.0,
        1.0, 1.0,
        0.0, 1.0,
        0.0, 0.0,
      
        # Top face
        0.0, 1.0,
        0.0, 0.0,
        1.0, 0.0,
        1.0, 1.0,
      
        # Bottom face
        1.0, 1.0,
        0.0, 1.0,
        0.0, 0.0,
        1.0, 0.0,
      
        # Right face
        1.0, 0.0,
        1.0, 1.0,
        0.0, 1.0,
        0.0, 0.0,
      
        # Left face
        0.0, 0.0,
        1.0, 0.0,
        1.0, 1.0,
        0.0, 1.0,
      ]
      
      @vertexNormals = [
        # Front face
         0.0,  0.0,  1.0,
         0.0,  0.0,  1.0,
         0.0,  0.0,  1.0,
         0.0,  0.0,  1.0,
      
        # Back face
         0.0,  0.0, -1.0,
         0.0,  0.0, -1.0,
         0.0,  0.0, -1.0,
         0.0,  0.0, -1.0,
      
        # Top face
         0.0,  1.0,  0.0,
         0.0,  1.0,  0.0,
         0.0,  1.0,  0.0,
         0.0,  1.0,  0.0,
      
        # Bottom face
         0.0, -1.0,  0.0,
         0.0, -1.0,  0.0,
         0.0, -1.0,  0.0,
         0.0, -1.0,  0.0,
      
        # Right face
         1.0,  0.0,  0.0,
         1.0,  0.0,  0.0,
         1.0,  0.0,  0.0,
         1.0,  0.0,  0.0,
      
        # Left face
        -1.0,  0.0,  0.0,
        -1.0,  0.0,  0.0,
        -1.0,  0.0,  0.0,
        -1.0,  0.0,  0.0,
      ]
      */

    };

    return PyramidMesh;

  })(Mesh);

  window.SquareMesh = SquareMesh = (function(_super) {
    __extends(SquareMesh, _super);

    function SquareMesh(size) {
      this.size = size != null ? size : 1;
      SquareMesh.__super__.constructor.apply(this, arguments);
    }

    SquareMesh.prototype.init = function() {
      var size;
      size = (this.size).operators("/",2);
      return this.vertexPositions = [size, size, 0.0, -size, size, 0.0, size, -size, 0.0, -size, -size, 0.0];
    };

    return SquareMesh;

  })(Mesh);

  window.TriangleMesh = SquareMesh = (function(_super) {
    __extends(SquareMesh, _super);

    function SquareMesh(size) {
      this.size = size != null ? size : 1;
      SquareMesh.__super__.constructor.apply(this, arguments);
    }

    SquareMesh.prototype.init = function() {
      var size;
      size = (this.size).operators("/",2);
      this.vertexPositions = [0.0, size, 0.0, -size, -size, 0.0, size, -size, 0.0];
      return this.vertexColors = [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0];
    };

    return SquareMesh;

  })(Mesh);

}).call(this);
